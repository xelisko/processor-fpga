////////////////////////////////////////// Mouse control function 
// Reset the previous mouse pointer 
@0x00 0x00       // Read RAM 30 (X_mouse_previous) to regA 
@0x01 0x30     //A = RAM 30
@0x02 0x01     // Read RAM 31 (Y_mouse_previous) to regB 
@0x03 0x31     // B = RAM 31 
@0x04 0x02       // Write regA to B0 (set x address of the mouse) 
@0x05 0xB0      
@0x06 0x03       // Write regB to B1 (set y address of the mouse) 
@0x07 0xB1      
@0x08 0x00     // Read B2 to regA (Read Pixel data out) 
@0x09 0xB2      
@0x0A 0x54     // regA = regA + 1 (inverse the Pixel data since it only has one bit) 
@0x0B 0x02     // Write regA to B2 (Update the Pixel data of the mouse pointer) 
@0x0C 0xB2
// Current mouse pointer 
@0x0D 0x00       // Read Mouse Driver (X_mouse) to regA 
@0x0E 0xA1     // A = mousex
@0x0F 0x02     // Write regA to RAM 30 - Record x address of the mouse 
@0x10 0x30     // ram30 = A
@0x11 0x02       // Write regA to B0 (send x coordinate of the VGA-X) 
@0x12 0xB0       // B0 = A
@0x13 0x02       // Write regA to D0 (send x coordinate of the 7Seg - left) 
@0x14 0xD0      // D0 = A
// calculation of the VGA-Y
@0x15 0x01     // Read Mouse Driver (Y_mouse) to regB 
@0x16 0xA2    // B = mousey
@0x17 0x03       // Write regB to D1 (set y coordinate of the 7Seg - right) 
@0x18 0xC1      // D1 = B
@0x19 0x00        //read from mem 0x0F to regA
@0x1A 0x0F      // A = 119
@0x1B 0x15     //B = A - B --> VGA_Y = 119 - Mouse_Y
//continue with updating the peripherals
@0x1C 0x03     // Write regB to RAM 31 - Record y address of the mouse 
@0x1D 0x31     //RAM 31 = B
@0x1E 0x03       // Write regB to B1 (set y coordinate of the VGA-Y) 
@0x1F 0xB1      //B1 = B
// inverse the pixel data
@0x20 0x00     // Read B2 to regA (Read Pixel data out) 
@0x21 0xB2      //A = B2
@0x22 0x54     // regA = regA + 1 (inverse the Pixel data since it only has one bit) 
@0x23 0x02     // Write regA to B2 (Update the Pixel data of the mouse pointer) 
@0x24 0xB2    // B2 = A
// Change the color
@0x25 0x00    // Read bus data of the mouse to regA 
@0x26 0xA0 
@0x27 0x01    // Read constant 9(RAM 0x10) to regB 
@0x28 0x10 
@0x29 0x96    // if bus data of the mouse is equal to 9, left button is pressed, Goto @0x2C
@0x2A 0x2D
@0x2B 0x07    // Left button of the mouse is not pressed, skip the color change, goto @0x36
@0x2C 0x36
@0x2D 0x00    // Read RAM 37 (VGA color) to regA 
@0x2E 0x37 
@0x2F 0x01    // Read RAM 0E to regB (4) 
@0x30 0x0E 
@0x31 0x04    // regA + regB (color + 4) 
@0x32 0x02    // Write regA to RAM 37 (Update the color to RAM) 
@0x33 0x37 
@0x34 0x02    // Write regA to B3 - Update the color to VGA 
@0x35 0xB3

// Pause
@0x36 0x00    // Read bus data of the mouse to regA 
@0x37 0xA0 
@0x38 0x01    // Read constant 10(RAM 0x12) to regB 
@0x39 0x12 
@0x3A 0x96    // if bus data of the mouse is equal to 8, right button is pressed, Goto @0x3D
@0x3B 0x3D
@0x3C 0xF8    // Left button of the mouse is not pressed, skip the color change, goto @0xF8
@0x3D 0x00 // Read VGA x to regA (beginning of the x loop)
@0x3E 0x35
@0x3F 0x01    // Read const 160 to regB
@0x40 0x0B
@0x41 0x96    // if VGA_x == 160, goto Y loop, @0x68
@0x42 0x68
@0x43 0x02    // Write VGA_x to VGA_controller
@0x44 0xB0
@0x45 0x01    // Read const 53 to regB
@0x46 0x22
@0x47 0x96    // if VGA_x == 53, set Pixel data in as 1, else 0, goto @0x5D
@0x48 0x5D
@0x49 0x01    // Read const 106 to regB
@0x4A 0x23
@0x4B 0x96    // if VGA_x == 106, set Pixel data in as 1, else 0, goto @0x5D
@0x4C 0x5D
@0x4D 0x00    // Read VGA_Y to regA
@0x4E 0x36
@0x4F 0x01    // Read const 40 to regB
@0x50 0x24
@0x51 0x96    // if VGA_y == 40, set Pixel data in as 1, else 0, goto @0x5D
@0x52 0x5D
@0x53 0x01    // Read const 80 to regB
@0x54 0x25
@0x55 0x96    // if VGA_y == 80, set Pixel data in as 1, else 0, goto @0x5D
@0x56 0x5D
@0x57 0x01    // Read const 0 to regB
@0x58 0x04
@0x59 0x03    // Write const 0 to B2 pixel data in
@0x5A 0xB2
@0x5B 0x07    // continue x loop, goto @0x61
@0x5C 0x61
@0x5D 0x01    // Read const 1 to regB
@0x5E 0x03
@0x5F 0x03    // Write const 0 to B2 pixel data in
@0x60 0xB2
@0x61 0x00    // Read VGA_X to regA
@0x62 0x35
@0x63 0x54    // VGA_X ++
@0x64 0x02    // Write next VGA_X to RAM 35
@0x65 0x35
@0x66 0x07    // Goto the beginning of x loop, goto @0x3D
@0x67 0x3D
@0x68 0x00    // Read const 0 to regA (beginning of the Y loop)
@0x69 0x04
@0x6A 0x02    // reset VGA_X by 0
@0x6B 0x35
@0x6C 0x00 // Read VGA Y to regA
@0x6D 0x36
@0x6E 0x02    // Write VGA_Y to VGA controller
@0x6F 0xB1
@0x70 0x54    // VGA_Y ++
@0x71 0x02    // Write the next VGA_Y to RAM @0x36
@0x72 0x36
@0x73 0x01    // Read const 120 to regB
@0x74 0x0C
@0x75 0x96    // if nxt VGA_Y == 120, reset VGA_Y then IDLE
@0x76 0x78
@0x77 0x07    // Goto the beginning og the x loop @0x3D
@0x78 0x3D
// Reset VGA_Y
@0x79 0x00    // Read const 0 to regA
@0x7A 0x04
@0x7B 0x02    // reset VGA_X by 0
@0x7C 0x36
// Goto IDLE
@0x7D 0xF8  // goto idle


 

// mouse naviagation function:
@0x80 0xf0   // regA = y direction from switches
@0x81 0xa2   
@0x82 0xf1  // regB up boundary 
@0x83 0x0A 
@0x84 0xa6  // branch if A>B
@0x85 0x92  // address up 
@0x86 0xf1  // regB down boundary 
@0x87 0x09
@0x88 0xb6  // branch if A<B
@0x89 0x99  // address down
@0x8a 0xf1 
@0x8b 0x04   
@0x8c 0xf3  // store direction 00
@0x8d 0x34
@0x8e 0xf7
@0x8f 0xa1  // branch to the new code
@0x91 //
@0x92 0xf1 // up 
@0x93 0x03  // 01
@0x94 0xf3
@0x95 0x34
@0x96 0xf7
@0x97 0xa1
@0x98 //
@0x99 0xf1  // down
@0x9a 0x06  // 10 - 2
@0x9b 0xf3
@0x9c 0x34
@0x9d 0xf7
@0x9e 0xa1
@0x9f //
@0xa0 //
@0xa1 0xf0  // x direction
@0xa2 0x30  // 
@0xa3 0xf1
@0xa4 0x08
@0xa5 0xa6
@0xa6 0xae  // address right
@0xa7 0xf1
@0xa8 0x07
@0xa9 0xb6   
@0xaa 0xba   // address left
@0xab 0xf7
@0xac 0xc6  
@0xad //
@0xae 0xf1  // right  -- 1000 (8)
@0xaf 0x11
@0xb0 0xf7  // skip
@0xb1 0xb2 
@0xb2 0xf0   // load y direction
@0xb3 0x34
@0xb4 0x05   // add directions
@0xb5 0xf3   // store final direction
@0xb6 0x34
@0xb7 0xf7   // go to the end function
@0xb8 0xc6
@0xb9 //
@0xba 0xf1  // left -- 100 (4)
@0xbb 0x0e  
@0xbc 0xf7   // skip  
@0xbd 0xbe
@0xbe 0xf0   // load y direction
@0xbf 0x34
@0xc0 0x05   // add directions
@0xc1 0xf3   // store final direction
@0xc2 0x34
@0xc3 0xf7   // go to the end function
@0xc4 0xc6

 

// send final direction to ir 
@0xc6 0xf1   //  load direction
@0xc7 0x34
@0xc8 0xf3   // ir
@0xc9 0x90
@0xca 0xf3   // 7 seg
@0xcb 0xd1
@0xcc 0xf3  // reset timer
@0xcd 0xf2
@0xce 0xf8  // idle

 

// timer interrupt - chose way of control
@0xd2 0xf0 // a - switch
@0xd3 0xe0
@0xd4 0xf1 // b - cons 1
@0xd5 0x03
@0xd6 0x96 // branch if a == b
@0xd7 0xe0
@0xd8 0xf7  // go to normal navigation
@0xd9 0x80

 

// button control:
@0xe0 0xf0 // load a = commands from buttons button control
@0xe1 0x95
@0xe2 0xf2  //  store to ir
@0xe3 0x90
@0xe4 0xf2  // 7seg
@0xe5 0xd1
@0xe6 0xf3   // reset timer
@0xe7 0xf2
@0xe8 0xf8   // idle

 


// interrupt calls 
@0xFE 0xd2 // timer interrupt 
@0xFF 0x00 // mouse interrupt
 

